"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _path = _interopRequireDefault(require("path"));

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class SourceMap {
  addEmptyMap(sourceName, sourceContent, lineOffset = 0) {
    this.sourceMapInstance.addEmptyMap(sourceName, sourceContent, lineOffset);
    return this;
  }

  addRawMappings(mappings, sources, names, lineOffset = 0, columnOffset = 0) {
    this.sourceMapInstance.addRawMappings(mappings, sources, names, lineOffset, columnOffset);
    return this;
  }

  addBufferMappings(buffer, lineOffset = 0, columnOffset = 0) {
    this.sourceMapInstance.addBufferMappings(buffer, lineOffset, columnOffset);
    return this;
  }

  addIndexedMapping(mapping, lineOffset = 0, columnOffset = 0) {
    let hasValidOriginal = mapping.original && typeof mapping.original.line === "number" && !isNaN(mapping.original.line) && typeof mapping.original.column === "number" && !isNaN(mapping.original.column);
    this.sourceMapInstance.addIndexedMapping(mapping.generated.line + lineOffset - 1, mapping.generated.column + columnOffset, // $FlowFixMe
    hasValidOriginal ? mapping.original.line - 1 : -1, // $FlowFixMe
    hasValidOriginal ? mapping.original.column : -1, mapping.source || "", mapping.name || "");
  } // line numbers start at 1 so we have the same api as `source-map` by mozilla


  addIndexedMappings(mappings, lineOffset = 0, columnOffset = 0) {
    for (let mapping of mappings) {
      this.addIndexedMapping(mapping, lineOffset, columnOffset);
    }

    return this;
  }

  addName(name) {
    return this.sourceMapInstance.addName(name);
  }

  addNames(names) {
    return names.map(n => this.addName(n));
  }

  addSource(source) {
    return this.sourceMapInstance.addSource(source);
  }

  addSources(sources) {
    return sources.map(s => this.addSource(s));
  }

  getSourceIndex(source) {
    return this.sourceMapInstance.getSourceIndex(source);
  }

  getSource(index) {
    return this.sourceMapInstance.getSource(index);
  }

  getNameIndex(name) {
    return this.sourceMapInstance.getNameIndex(name);
  }

  getName(index) {
    return this.sourceMapInstance.getName(index);
  }

  indexedMappingToStringMapping(mapping) {
    if (!mapping) return mapping;

    if (mapping.source != null && mapping.source > -1) {
      // $FlowFixMe
      mapping.source = this.getSource(mapping.source);
    }

    if (mapping.name != null && mapping.name > -1) {
      // $FlowFixMe
      mapping.name = this.getName(mapping.name);
    } // $FlowFixMe


    return mapping;
  }

  findClosestMapping(line, column) {
    let mapping = this.sourceMapInstance.findClosestMapping(line, column);
    return this.indexedMappingToStringMapping(mapping);
  } // Remaps original positions from this map to the ones in the provided map


  extends(buffer) {
    this.sourceMapInstance.extends(buffer);
    return this;
  }

  getMap() {
    return this.sourceMapInstance.getMap();
  }

  toBuffer() {
    return this.sourceMapInstance.toBuffer();
  }

  toVLQ() {
    return this.sourceMapInstance.stringify();
  }

  async stringify(options) {
    return (0, _utils.partialVlqMapToSourceMap)(this.toVLQ(), options);
  }

}

exports.default = SourceMap;